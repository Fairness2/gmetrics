// Code generated by MockGen. DO NOT EDIT.
// Source: internal/metrics/adapter.go

// Package metrics is a generated GoMock package.
package metrics

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockITX is a mock of ITX interface.
type MockITX struct {
	ctrl     *gomock.Controller
	recorder *MockITXMockRecorder
}

// MockITXMockRecorder is the mock recorder for MockITX.
type MockITXMockRecorder struct {
	mock *MockITX
}

// NewMockITX creates a new mock instance.
func NewMockITX(ctrl *gomock.Controller) *MockITX {
	mock := &MockITX{ctrl: ctrl}
	mock.recorder = &MockITXMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITX) EXPECT() *MockITXMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockITX) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockITXMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockITX)(nil).Commit))
}

// ExecContext mocks base method.
func (m *MockITX) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockITXMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockITX)(nil).ExecContext), varargs...)
}

// PrepareContext mocks base method.
func (m *MockITX) PrepareContext(ctx context.Context, query string) (IStmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(IStmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareContext indicates an expected call of PrepareContext.
func (mr *MockITXMockRecorder) PrepareContext(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockITX)(nil).PrepareContext), ctx, query)
}

// Rollback mocks base method.
func (m *MockITX) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockITXMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockITX)(nil).Rollback))
}

// MockIRows is a mock of IRows interface.
type MockIRows struct {
	ctrl     *gomock.Controller
	recorder *MockIRowsMockRecorder
}

// MockIRowsMockRecorder is the mock recorder for MockIRows.
type MockIRowsMockRecorder struct {
	mock *MockIRows
}

// NewMockIRows creates a new mock instance.
func NewMockIRows(ctrl *gomock.Controller) *MockIRows {
	mock := &MockIRows{ctrl: ctrl}
	mock.recorder = &MockIRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIRows) EXPECT() *MockIRowsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIRows) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIRowsMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIRows)(nil).Close))
}

// Err mocks base method.
func (m *MockIRows) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockIRowsMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockIRows)(nil).Err))
}

// Next mocks base method.
func (m *MockIRows) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockIRowsMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockIRows)(nil).Next))
}

// Scan mocks base method.
func (m *MockIRows) Scan(dest ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockIRowsMockRecorder) Scan(dest ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIRows)(nil).Scan), dest...)
}

// MockIRow is a mock of IRow interface.
type MockIRow struct {
	ctrl     *gomock.Controller
	recorder *MockIRowMockRecorder
}

// MockIRowMockRecorder is the mock recorder for MockIRow.
type MockIRowMockRecorder struct {
	mock *MockIRow
}

// NewMockIRow creates a new mock instance.
func NewMockIRow(ctrl *gomock.Controller) *MockIRow {
	mock := &MockIRow{ctrl: ctrl}
	mock.recorder = &MockIRowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIRow) EXPECT() *MockIRowMockRecorder {
	return m.recorder
}

// Scan mocks base method.
func (m *MockIRow) Scan(dest ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockIRowMockRecorder) Scan(dest ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIRow)(nil).Scan), dest...)
}

// MockIResult is a mock of IResult interface.
type MockIResult struct {
	ctrl     *gomock.Controller
	recorder *MockIResultMockRecorder
}

// MockIResultMockRecorder is the mock recorder for MockIResult.
type MockIResultMockRecorder struct {
	mock *MockIResult
}

// NewMockIResult creates a new mock instance.
func NewMockIResult(ctrl *gomock.Controller) *MockIResult {
	mock := &MockIResult{ctrl: ctrl}
	mock.recorder = &MockIResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIResult) EXPECT() *MockIResultMockRecorder {
	return m.recorder
}

// LastInsertId mocks base method.
func (m *MockIResult) LastInsertId() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastInsertId")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LastInsertId indicates an expected call of LastInsertId.
func (mr *MockIResultMockRecorder) LastInsertId() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastInsertId", reflect.TypeOf((*MockIResult)(nil).LastInsertId))
}

// RowsAffected mocks base method.
func (m *MockIResult) RowsAffected() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsAffected")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsAffected indicates an expected call of RowsAffected.
func (mr *MockIResultMockRecorder) RowsAffected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsAffected", reflect.TypeOf((*MockIResult)(nil).RowsAffected))
}

// MockIStmt is a mock of IStmt interface.
type MockIStmt struct {
	ctrl     *gomock.Controller
	recorder *MockIStmtMockRecorder
}

// MockIStmtMockRecorder is the mock recorder for MockIStmt.
type MockIStmtMockRecorder struct {
	mock *MockIStmt
}

// NewMockIStmt creates a new mock instance.
func NewMockIStmt(ctrl *gomock.Controller) *MockIStmt {
	mock := &MockIStmt{ctrl: ctrl}
	mock.recorder = &MockIStmtMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStmt) EXPECT() *MockIStmtMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIStmt) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIStmtMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIStmt)(nil).Close))
}

// Exec mocks base method.
func (m *MockIStmt) Exec(args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockIStmtMockRecorder) Exec(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIStmt)(nil).Exec), args...)
}
